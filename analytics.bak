library(data.table)
library(dplyr)
library(lubridate)
library(readr)
library(tidyr)
library(purrr)


# --- 1. CONFIGURACIÓN ---
# Usamos una ruta absoluta para evitar problemas de carpetas
base_path <- "/home/rserranoga/v16monitor"
setwd(base_path)

data_dir     <- file.path(base_path, "data")
analysis_dir <- file.path(base_path, "analysis")

if(!dir.exists(analysis_dir)) dir.create(analysis_dir, recursive = TRUE)

output_hourly      <- file.path(analysis_dir, "stats_hourly_summary.csv")
output_daily       <- file.path(analysis_dir, "stats_daily_summary.csv")
output_roads_top   <- file.path(analysis_dir, "stats_roads_top.csv")
output_roads_daily <- file.path(analysis_dir, "stats_roads_daily.csv")

Sys.setlocale("LC_TIME", "es_ES.UTF-8")

# --- 2. MOTOR DE DEDUPLICACIÓN ---
load_clean_data <- function(hours_back = NULL) {
  files <- list.files(data_dir, pattern = "_dgt_balizas\\.csv$", full.names = TRUE)
  if(length(files) == 0) return(NULL)
  
  raw_df <- map_dfr(files, ~{
    dt <- data.table::fread(.x, colClasses = "character", showProgress = FALSE)
    if(!"Case_id" %in% names(dt)) return(NULL)
    return(as_tibble(dt))
  })
  
  clean_df <- raw_df %>%
    mutate(
      mins = as.numeric(mins),
      Start_Time = as_datetime(Start_Time),
      PK_num = as.numeric(gsub("[^0-9.]", "", as.character(PK)))
    ) %>%
    group_by(Case_id) %>%
    summarise(
      Start_Time = min(Start_Time, na.rm = TRUE),
      mins = max(mins, na.rm = TRUE),
      Prov = first(Prov), Road = first(Road), PK = first(PK_num),
      .groups = "drop"
    ) %>%
    mutate(
      Hour_Bucket = floor_date(Start_Time, "hour"),
      Bracket = case_when(
        hour(Hour_Bucket) < 6  ~ "00:00-06:00",
        hour(Hour_Bucket) < 12 ~ "06:00-12:00",
        hour(Hour_Bucket) < 18 ~ "12:00-18:00",
        TRUE                   ~ "18:00-00:00"
      )
    )
  
  return(clean_df)
}


run_hourly <- function() {
  message(paste("Iniciando análisis horario robusto:", Sys.time()))
  
  # 1. Cargar datos de las últimas 24 horas para asegurar que no hay huecos
  df <- load_clean_data(hours_back = 24)
  if(is.null(df) || nrow(df) == 0) return(message("No se encontraron datos en las últimas 24h."))
  
  # --- SECCIÓN A: CÁLCULO DE ESTADÍSTICAS (NACIONAL/PROVINCIAL) ---
  new_stats <- bind_rows(
    df %>% group_by(Timestamp = Hour_Bucket, Level = "Nacional", Scope = "Total") %>%
      summarise(Count = n(), Avg_Mins = mean(mins, na.rm=T), Med_Mins = median(mins, na.rm=T), .groups = "drop"),
    df %>% group_by(Timestamp = Hour_Bucket, Prov) %>%
      summarise(Level = "Provincial", Scope = first(Prov), Count = n(), Avg_Mins = mean(mins, na.rm=T), Med_Mins = median(mins, na.rm=T), .groups = "drop")
  )

  # Mezclar y deduplicar Estadísticas
  if(file.exists(output_hourly)) {
  #  existing_stats <- read_csv(output_hourly, show_col_types = FALSE)
    existing_stats <- read_csv(output_hourly, col_types = cols(
      Timestamp = col_datetime(),
      Level = col_character(),
      Scope = col_character(),
      Count = col_double(),
      Avg_Mins = col_double(),
      Med_Mins = col_double()
    ))

    final_stats <- bind_rows(existing_stats, new_stats) %>%
      distinct(Timestamp, Level, Scope, .keep_all = TRUE) %>%
      arrange(desc(Timestamp))
  } else {
    final_stats <- new_stats
  }
  write_csv(final_stats, output_hourly)

  # --- SECCIÓN B: CÁLCULO DE CARRETERAS TOP ---
  new_roads <- df %>%
    group_by(Timestamp = Hour_Bucket, Prov, Road) %>%
    reframe(
      Count = n(),
      Min_PK = min(PK, na.rm = TRUE), 
      Max_PK = max(PK, na.rm = TRUE), 
      Bracket = first(Bracket)
    ) %>%
    group_by(Timestamp, Prov) %>%
    # slice_max(Count, n = 1, with_ties = FALSE)
    arrange(desc(Count))

  # Mezclar y deduplicar Carreteras (Corregido)
  if(file.exists(output_roads_top)) {
    # Forzamos tipos de columna para evitar errores de mismatch
    existing_roads <- read_csv(output_roads_top, col_types = cols(
      Timestamp = col_datetime(),
      Prov = col_character(),
      Road = col_character(),
      Count = col_double(),
      Min_PK = col_double(),
      Max_PK = col_double(),
      Bracket = col_character()
    ))
    
    final_roads <- bind_rows(existing_roads, new_roads) %>%
      distinct(Timestamp, Prov, Road, .keep_all = TRUE) %>%
      arrange(desc(Timestamp))
  } else {
    final_roads <- new_roads
  }
  
  write_csv(final_roads, output_roads_top)
}

# --- 4. LÓGICA DIARIA ---
run_daily <- function() {
  message(paste("Iniciando análisis diario completo:", Sys.time()))
  
  if(!file.exists(output_hourly) | !file.exists(output_roads_top)) {
    return(message("Error: Faltan archivos horarios para generar los resúmenes diarios."))
  }
  
  # --- SECCIÓN A: RESUMEN DE ESTADÍSTICAS DIARIAS ---
  hourly_data <- read_csv(output_hourly, col_types = cols(Timestamp = col_datetime(), .default = col_guess()))
  
  new_daily_stats <- hourly_data %>%
    mutate(Date = as.Date(Timestamp)) %>%
    group_by(Level, Scope, Date) %>%
    summarise(
      Wday = format(first(Date), "%A"),
      Daily_Count = sum(Count, na.rm = TRUE),
      Daily_Avg_Mins = mean(Avg_Mins, na.rm = TRUE),
      Daily_Med_Mins = median(Med_Mins, na.rm = TRUE),
      .groups = "drop"
    )

  if(file.exists(output_daily)) {
    existing_daily <- read_csv(output_daily, col_types = cols(Date = col_date(), .default = col_guess()))
    final_daily <- bind_rows(new_daily_stats, existing_daily) %>%
      distinct(Level, Scope, Date, .keep_all = TRUE) %>%
      arrange(desc(Date))
  } else {
    final_daily <- new_daily_stats
  }
  write_csv(final_daily, output_daily)

  # --- SECCIÓN B: RESUMEN DE CARRETERAS DIARIAS ---
  roads_hourly <- read_csv(output_roads_top, col_types = cols(Timestamp = col_datetime(), .default = col_guess()))
  
  new_daily_roads <- roads_hourly %>%
    mutate(Date = as.Date(Timestamp)) %>%
    group_by(Date, Prov, Road) %>%
	summarise(
      	Hours_Active = n(), 
      	Total_Incidents = sum(Count, na.rm = TRUE), # Add this to see volume
      	.groups = "drop"
    	)
    #arrange(desc(Count))
    #slice_max(Hours_Active, n = 1, with_ties = FALSE) # Elige la carretera que más horas apareció

  if(file.exists(output_roads_daily)) {
    existing_roads_daily <- read_csv(output_roads_daily, col_types = cols(Date = col_date(), .default = col_guess()))
    final_roads_daily <- bind_rows(new_daily_roads, existing_roads_daily) %>%
      distinct(Date, Prov, .keep_all = TRUE) %>%
      arrange(desc(Date))
  } else {
    final_roads_daily <- new_daily_roads
  }
  write_csv(final_roads_daily, output_roads_daily)
  
  message("¡Análisis diario (Estadísticas y Carreteras) completado con éxito!")
}

# --- 5. DISPATCHER SEGURO ---
# --- BOILERPLATE EXECUTION ---
args <- commandArgs(trailingOnly = TRUE)

if (length(args) > 0) {
  if (args[1] == "hourly") {
    run_hourly()
  } else if (args[1] == "daily") {
    run_daily()
  }
} else {
  message("Uso manual: Rscript analytics.R hourly")
}

